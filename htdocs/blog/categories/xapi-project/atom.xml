<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Xapi-project | Jon Ludlam's Blog]]></title>
  <link href="http://jon.recoil.org//blog/categories/xapi-project/atom.xml" rel="self"/>
  <link href="http://jon.recoil.org//"/>
  <updated>2014-06-13T23:48:33+01:00</updated>
  <id>http://jon.recoil.org//</id>
  <author>
    <name><![CDATA[Jon Ludlam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Tracking Down Stress Test Bugs in Xapi]]></title>
    <link href="http://jon.recoil.org//blog/2014/06/12/tracking-down-stress-test-bugs-in-xapi/"/>
    <updated>2014-06-12T15:59:38+01:00</updated>
    <id>http://jon.recoil.org//blog/2014/06/12/tracking-down-stress-test-bugs-in-xapi</id>
    <content type="html"><![CDATA[<p>We had an issue reported by XenRT that xapi was failing during a
stress test while halting a VM, reporting an internal error from
xenopsd: &ldquo;Object does not exist in xenopsd&rdquo;.</p>

<p>Looking through /var/log/xensource.log, the API call comes in
for processing at 19:31:44:</p>

<p><code>
May  2 19:31:44 localhost xapi: [ info|cl11-08|46298 INET 0.0.0.0:80|dispatch:VM.clean_shutdown D:fa4c1c72df7e|taskhelper] task Async.VM.clean_shutdown R:82f033257476 forwarded (trackid=8354dc542edb45d9d747e9c1d992c886)
</code></p>

<p>Xapi log lines are very long and contain quite a lot of
info. Decomposing it a bit, this particular line is an info message on
host cl11-08, thread id 46298 from the TCP port listening to
0.0.0.0:80. It&rsquo;s a task called <code>dispatch:VM.clean_shutdown</code>, which has
task id <code>D:fa4c1c72df7e</code>, and comes from a logger named <code>taskhelper</code>,
which is defined
<a href="https://github.com/xapi-project/xen-api/blob/9abf1c73923598b3598e41e539ec49d60c51c588/ocaml/idl/ocaml_backend/taskHelper.ml#L14">here</a>
The log message says that there&rsquo;s a new task &lsquo;Async.VM.clean_shutdown&rsquo;
with task id R:82f033257476, which has been forwarded from the pool
master.</p>

<p>The bit we&rsquo;re interested in here is that the new task id is
<code>R:82f033257476</code>, and we can grep for this in the logs to see only the
messages associated with this API call. Doing that and skipping a few
uninteresting lines, we see that xapi decides this is an OK thing to
process, and in turn tells xenopsd to halt the VM:</p>

<p><code>
May  2 19:31:44 localhost xapi: [debug|cl11-08|46298 INET 0.0.0.0:80|Async.VM.clean_shutdown R:82f033257476|mscgen] xapi=&gt;xenops [label="VM.shutdown"];
May  2 19:31:44 localhost xenopsd: [debug|cl11-08|7|Async.VM.clean_shutdown R:82f033257476|xenops] Task 7729 reference Async.VM.clean_shutdown R:82f033257476: ["VM_poweroff", ["4ab3dfd9-f571-8900-a35a-6cced68267e3", [1200.000000]]]
</code></p>

<p>The <code>mscgen</code> line shows an internal <code>VM.shutdown</code> call from xapi to
xenopsd.  The entry points for all of the xenopsd API calls are in the
file xenopsd.git/lib/xenops_server.ml, and this particular call is
handled
<a href="https://github.com/xapi-project/xenopsd/blob/25fc99435dbe5093b10f8727198a94097ba22031/lib/xenops_server.ml#L1727">here</a>
which shows why xenopsd logs it as VM_poweroff.</p>

<p>Xenopsd turns this API call into
<a href="https://github.com/xapi-project/xenopsd/blob/25fc99435dbe5093b10f8727198a94097ba22031/lib/xenops_server.ml#L809">several smaller items</a>
and starts processing them, logging when it starts each one:</p>

<p><code>
May  2 19:31:44 localhost xenopsd: [debug|cl11-08|7|Async.VM.clean_shutdown R:82f033257476|xenops] Performing: ["VM_hook_script", ["4ab3dfd9-f571-8900-a35a-6cced68267e3", "VM_pre_destroy", "clean-shutdown"]]
...
May  2 19:31:44 localhost xenopsd: [debug|cl11-08|7|Async.VM.clean_shutdown R:82f033257476|xenops] Performing: ["VM_shutdown_domain", ["4ab3dfd9-f571-8900-a35a-6cced68267e3", "Halt", 1200.000000]]
...
May  2 19:32:09 localhost xenopsd: [debug|cl11-08|7|Async.VM.clean_shutdown R:82f033257476|xenops] Performing: ["VM_destroy_device_model", "4ab3dfd9-f571-8900-a35a-6cced68267e3"]
...
May  2 19:32:09 localhost xenopsd: [debug|cl11-08|7|Async.VM.clean_shutdown R:82f033257476|xenops] Performing: ["VBD_unplug", ["4ab3dfd9-f571-8900-a35a-6cced68267e3", "xvda"], true]
...
May  2 19:32:25 localhost xenopsd: [debug|cl11-08|7|Async.VM.clean_shutdown R:82f033257476|xenops] Performing: ["VIF_unplug", ["4ab3dfd9-f571-8900-a35a-6cced68267e3", "0"], true]
...
May  2 19:32:26 localhost xenopsd: [debug|cl11-08|7|Async.VM.clean_shutdown R:82f033257476|xenops] Performing: ["VM_destroy", "4ab3dfd9-f571-8900-a35a-6cced68267e3"]
...
May  2 19:32:26 localhost xenopsd: [debug|cl11-08|7|Async.VM.clean_shutdown R:82f033257476|xenops] Performing: ["VBD_epoch_end", [["4ab3dfd9-f571-8900-a35a-6cced68267e3", "xvda"], ["VDI", "0da34c7b-b27b-20c3-7e29-50659204a52e\/9f380254-3a77-452a-aea3-8031226c6cc7"]]]
...
May  2 19:32:45 localhost xenopsd: [debug|cl11-08|7|Async.VM.clean_shutdown R:82f033257476|xenops] Performing: ["VBD_set_active", ["4ab3dfd9-f571-8900-a35a-6cced68267e3", "xvda"], false]
May  2 19:32:45 localhost xenopsd: [debug|cl11-08|7|Async.VM.clean_shutdown R:82f033257476|xenops] VBD.set_active 4ab3dfd9-f571-8900-a35a-6cced68267e3.xvda false
May  2 19:32:45 localhost xenopsd: [ info|cl11-08|7|Async.VM.clean_shutdown R:82f033257476|xenops] Caught Xenops_interface.Does_not_exist(_) executing ["VM_poweroff", ["4ab3dfd9-f571-8900-a35a-6cced68267e3", [1200.000000]]]: triggering cleanup actions
</code></p>

<p>The first thing to notice is that the system must be really busy, as
it takes over a minute to fail to poweroff the VM. We can also clearly
see that it&rsquo;s in processing the <code>VBD.set_active</code> task that the failure
occurs. Unhelpfully, the body of the exception <code>Does_not_exist</code> has
been hidden, but fortunately xenopsd logs the full details a few lines
later:</p>

<p><code>
May  2 19:32:45 localhost xenopsd: [debug|cl11-08|7|Async.VM.clean_shutdown R:82f033257476|xenops] Task 7729 failed; exception = ["Does_not_exist", ["VM", "4ab3dfd9-f571-8900-a35a-6cced68267e3\/vbd.xvda"]]
</code></p>

<p>and so it&rsquo;s complaining that the <em>VM</em> does not exist. This can only
have happened by a VM.remove call being processed by xenopsd. Grepping
for this:</p>

<p><code>
May  2 19:32:31 localhost xapi: [debug|cl11-08|74|xenops events D:337bbe7c241d|xenops] Processing event: ["Vm", "4ab3dfd9-f571-8900-a35a-6cced68267e3"]
May  2 19:32:31 localhost xapi: [debug|cl11-08|74|xenops events D:337bbe7c241d|xenops] xenops event on VM 4ab3dfd9-f571-8900-a35a-6cced68267e3
May  2 19:32:31 localhost xapi: [debug|cl11-08|74|xenops events D:337bbe7c241d|mscgen] xapi=&gt;xenops [label="VM.stat"];
May  2 19:32:31 localhost xenopsd: [debug|cl11-08|13680588|xenops events D:337bbe7c241d|xenops] VM.stat 4ab3dfd9-f571-8900-a35a-6cced68267e3
May  2 19:32:31 localhost xapi: [debug|cl11-08|74|xenops events D:337bbe7c241d|xenops] xenopsd event: processing event for VM 4ab3dfd9-f571-8900-a35a-6cced68267e3
May  2 19:32:31 localhost xapi: [debug|cl11-08|74|xenops events D:337bbe7c241d|xenops] Will update VM.allowed_operations because power_state has changed.
May  2 19:32:31 localhost xapi: [debug|cl11-08|74|xenops events D:337bbe7c241d|xenops] xenopsd event: Updating VM 4ab3dfd9-f571-8900-a35a-6cced68267e3 power_state &lt;- Halted
May  2 19:32:33 localhost xapi: [debug|cl11-08|74|xenops events D:337bbe7c241d|xenops] xenops_cache: deleting cache for 4ab3dfd9-f571-8900-a35a-6cced68267e3
May  2 19:32:33 localhost xapi: [debug|cl11-08|74|xenops events D:337bbe7c241d|xenops] xapi_cache: deleting cache for 4ab3dfd9-f571-8900-a35a-6cced68267e3
May  2 19:32:33 localhost xapi: [ info|cl11-08|74|xenops events D:337bbe7c241d|xenops] xenops: VM.remove 4ab3dfd9-f571-8900-a35a-6cced68267e3
May  2 19:32:33 localhost xapi: [debug|cl11-08|74|xenops events D:337bbe7c241d|mscgen] xapi=&gt;xenops [label="VM.remove"];
</code></p>

<p>So xapi told xenopsd to remove the VM! The clue here is in the name of
the thread: <code>xenops events</code>.  Xapi has to be able to respond to events
initiated by the VM, for example, the VM may shut down at any time and
xapi needs to reflect this in its database. Therefore a thread exists
in xapi that monitors xenopsd for events. This thread has noticed that
the VM has shut down and attempts to clean things up. Normally this
isn&rsquo;t a problem as xenopsd only marks the VM as shut down when it
performs the <code>VM_destroy</code> towards the end of its shutdown actions, and
in any case it wouldn&rsquo;t usually signal an event on the VM until
completely finishing the sequence.</p>

<p>In this case, probably because the whole system was very busy, the
event thread presumably had a long queue of events to process,
including one that came from this VM from before the shutdown was
initiated. This was then processed at an unfortunate time, leading to
the problem. To confirm, we can inject this sort of failure by
modifying the sequence of events that happens during a shutdown:</p>

<p>From this:</p>

<p>``` ocaml Decompose the poweroff into atomic operations
| VM_poweroff (id, timeout) &ndash;></p>

<pre><code>let reason =
    if timeout = None
    then Xenops_hooks.reason__hard_shutdown
    else Xenops_hooks.reason__clean_shutdown in
[
    VM_hook_script(id, Xenops_hooks.VM_pre_destroy, reason);
] @ (atomics_of_operation (VM_shutdown (id, timeout))
) @ (List.concat (List.map (fun vbd -&gt; Opt.default [] (Opt.map (fun x -&gt; [ VBD_epoch_end (vbd.Vbd.id, x)] ) vbd.Vbd.backend))
    (VBD_DB.vbds id)
)) @ (List.map (fun vbd -&gt; VBD_set_active (vbd.Vbd.id, false))
    (VBD_DB.vbds id)
) @ (List.map (fun vif -&gt; VIF_set_active (vif.Vif.id, false))
    (VIF_DB.vifs id)
) @ [
    VM_hook_script(id, Xenops_hooks.VM_post_destroy, reason)
]
</code></pre>

<p>```</p>

<p>we&rsquo;ll stick in a delay:</p>

<p>``` ocaml Inject the defect
| VM_poweroff (id, timeout) &ndash;></p>

<pre><code>let reason =
    if timeout = None
    then Xenops_hooks.reason__hard_shutdown
    else Xenops_hooks.reason__clean_shutdown in
[
    VM_hook_script(id, Xenops_hooks.VM_pre_destroy, reason);
] @ (atomics_of_operation (VM_shutdown (id, timeout))
) @ [ VM_delay (id, 10.0);
] @ (List.concat (List.map (fun vbd -&gt; Opt.default [] (Opt.map (fun x -&gt; [ VBD_epoch_end (vbd.Vbd.id, x)] ) vbd.Vbd.backend))
    (VBD_DB.vbds id)
)) @ (List.map (fun vbd -&gt; VBD_set_active (vbd.Vbd.id, false))
    (VBD_DB.vbds id)
) @ (List.map (fun vif -&gt; VIF_set_active (vif.Vif.id, false))
    (VIF_DB.vifs id)
) @ [
    VM_hook_script(id, Xenops_hooks.VM_post_destroy, reason)
]
</code></pre>

<p>```</p>

<p>and separately cause the <code>VM_delay</code> atomic operation to inject an event that xapi
will pick up:</p>

<p>``` ocaml
| VM_delay (id, t) &ndash;></p>

<pre><code>Updates.add (Dynamic.Vm id) updates;
debug "VM %s: waiting for %.2f before next VM action" id t;
Thread.delay t
</code></pre>

<p>```</p>

<p>where that &lsquo;Updates.add&rsquo; is what will wake xapi.
Compiling this up and uploading it to our server, the problem is easily reproduced:</p>

<p><code>
[root@st28 ~]# xe vm-shutdown vm=centos
The server failed to handle your request, due to an internal error.  The given message may give details useful for debugging the problem.
message: Object with type VM and id 41bcbb30-31b6-5d97-37ad-c8b1f985c064/vbd.xvdd does not exist in xenopsd
</code></p>

<p>Now we just need to decide how to fix this. It seems bad that invoking
this API call to xenopsd can cause it an internal error, so the
problem should clearly be fixed in xenopsd as opposed to within xapi.
Fortunately xenopsd already has logic for this sort of thing: It has
system of worker threads that perform the larger operations and a way
of queuing operations to be processed. This allows xenopsd to process
several operations at the same time.</p>

<p>When a new VM-specific operation is queued, xenopsd looks to see if a
worker thread is already processing operations on that particular
VM. If so, the operation is given to that worker&rsquo;s personal queue, and
if not, the operation is put onto the default queue. When a worker is
looking for a job to do, it pops the next operation off the default
queue, and also allocates all other operations on the same VM to
itself.  In this way we never have two workers trying to operate on
the same VM.</p>

<p>The solution is therefore to use this mechanism to queue up the VM.remove
behind the VM.shutdown. Unfortunately it&rsquo;s usually only the async
operations that are queued, so we have to add in a bit more logic to
make the operation still appear to be synchronous, while actually
implementing it using the asynchronous task mechanisms.</p>

<p>```
commit b8e590ceb968fa87845b75d95ecc85214255e94f
Author: Jon Ludlam <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x6a;&#111;&#110;&#97;&#x74;&#x68;&#97;&#x6e;&#x2e;&#x6c;&#x75;&#x64;&#x6c;&#97;&#x6d;&#64;&#x63;&#105;&#x74;&#x72;&#105;&#120;&#46;&#x63;&#x6f;&#109;">&#106;&#111;&#x6e;&#x61;&#116;&#104;&#97;&#110;&#x2e;&#x6c;&#x75;&#x64;&#108;&#97;&#109;&#64;&#99;&#x69;&#116;&#x72;&#105;&#120;&#x2e;&#x63;&#x6f;&#x6d;</a>
Date:   Thu Jun 12 23:23:20 2014 +0100</p>

<pre><code>Queue the VM.remove operation

Signed-off-by: Jon Ludlam &lt;jonathan.ludlam@citrix.com&gt;
</code></pre>

<p>diff &mdash;git a/lib/xenops_server.ml b/lib/xenops_server.ml
index b470891..51f0b3d 100644
&mdash;&ndash; a/lib/xenops_server.ml
+++ b/lib/xenops_server.ml
@@ -1448,11 +1448,20 @@ and perform ?subtask (op: operation) (t: Xenops_task.t) : unit =</p>

<pre><code>            | None -&gt; one op
            | Some name -&gt; Xenops_task.with_subtask t name (fun () -&gt; one op)
</code></pre>

<p>-let queue_operation dbg id op =
+let queue_operation_int dbg id op =</p>

<pre><code>    let task = Xenops_task.add tasks dbg (fun t -&gt; perform op t; None) in
    Redirector.push id (op, task);
</code></pre>

<ul>
<li><pre><code>task
</code></pre>

<p>+
+let queue_operation dbg id op =</p></li>
<li><pre><code>let task = queue_operation_int dbg id op in
task.Xenops_task.id
</code></pre></li>
</ul>


<p>+let queue_operation_and_wait dbg id op =
+       let from = Updates.last_id dbg updates in
+       let task = queue_operation_int dbg id op in
+       event_wait task ~from 1200.0 (task_finished_p task.Xenops_task.id)
+
 module PCI = struct</p>

<pre><code>    open Pci
    module DB = PCI_DB
</code></pre>

<p>@@ -1670,7 +1679,7 @@ module VM = struct</p>

<pre><code>    let add _ dbg x =
            Debug.with_thread_associated dbg (fun () -&gt; add' x) ()
</code></pre>

<ul>
<li><pre><code>let remove _ dbg id = immediate_operation dbg id (Atomic(VM_remove id))
</code></pre></li>
<li><pre><code>let remove _ dbg id = queue_operation_and_wait dbg id (Atomic (VM_remove id)) |&gt; ignore

let stat' x =
        debug "VM.stat %s" x;
</code></pre>

<p>```</p></li>
</ul>


<p>And indeed, with <a href="https://github.com/xapi-project/xenopsd/pull/77">this queuing in place</a> the problem doesn&rsquo;t happen even
with our fault injection code activated.</p>
]]></content>
  </entry>
  
</feed>
